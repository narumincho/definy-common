/* eslint-disable */
/* generated by js-ts-code-generator. Do not edit! */

import * as a from "util";

/**
 * UserId, ProjectIdなどのIdをバイナリ形式にエンコードする
 */
export const encodeId = (value: string): ReadonlyArray<number> => {
  const result: Array<number> = [];
  for (let i = 0; i < 16; i += 1) {
    result[i] = Number.parseInt(value.slice(i * 2, i * 2 + 2), 16);
  }
  return result;
};

/**
 * バイナリ形式をUserId, ProjectIdなどのIdにデコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeId = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 16)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 16,
});

/**
 * ImageTokenなどのTokenをバイナリ形式にエンコードする
 */
export const encodeToken = (value: string): ReadonlyArray<number> => {
  const result: Array<number> = [];
  for (let i = 0; i < 32; i += 1) {
    result[i] = Number.parseInt(value.slice(i * 2, i * 2 + 2), 16);
  }
  return result;
};

/**
 * バイナリ形式をImageTokenなどのTokenにエンコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeToken = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 32)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 32,
});

/**
 * バイナリと相互変換するための関数
 */
export type Codec<T extends unknown> = {
  readonly encode: (a: T) => ReadonlyArray<number>;
  readonly decode: (
    a: number,
    b: Uint8Array
  ) => { readonly result: T; readonly nextIndex: number };
};

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 *  @typePartId ccf22e92cea3639683c0271d65d00673
 */
export type Int32 = number;

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 *  @typePartId 743d625544767e750c453fa344194599
 */
export type Binary = Uint8Array;

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 *  @typePartId 93e91ed730b5e7689250a76096ae60a4
 */
export type Bool = boolean;

/**
 * リスト. JavaScriptのArrayで扱う
 *  @typePartId d7a1efe440138793962eed5625de8196
 */
export type List<e extends unknown> = ReadonlyArray<e>;

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつける?
 *  @typePartId cdd7dd74dd0f2036b44dcae6aaac46f5
 */
export type Maybe<value extends unknown> =
  | { readonly _: "Just"; readonly value: value }
  | { readonly _: "Nothing" };

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 *  @typePartId 943ef399d0891f897f26bc02fa24af70
 */
export type Result<ok extends unknown, error extends unknown> =
  | { readonly _: "Ok"; readonly ok: ok }
  | { readonly _: "Error"; readonly error: error };

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 *  @typePartId f1f830d23ffab8cec4d0191d157b9fc4
 */
export type String = string;

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 *  @typePartId fa64c1721a3285f112a4118b66b43712
 */
export type Time = {
  /**
   * 1970-01-01からの経過日数. マイナスになることもある
   */
  readonly day: Int32;
  /**
   * 日にちの中のミリ秒. 0 to 86399999 (=1000*60*60*24-1)
   */
  readonly millisecond: Int32;
};

/**
 * ログインのURLを発行するために必要なデータ
 *  @typePartId db245392b9296a48a195e4bd8824dd2b
 */
export type RequestLogInUrlRequestData = {
  /**
   * ログインに使用するプロバイダー
   */
  readonly openIdConnectProvider: OpenIdConnectProvider;
  /**
   * ログインした後に返ってくるURLに必要なデータ
   */
  readonly urlData: UrlData;
};

/**
 * ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 *  @typePartId 0264130f1d9473f670907755cbee50d9
 */
export type OpenIdConnectProvider = "Google" | "GitHub";

/**
 * デバッグモードかどうか,言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある. デバッグ時のホスト名は http://localhost になる
 *  @typePartId dc3b3cd3f125b344fb60a91c0b184f3e
 */
export type UrlData = {
  /**
   * クライアントモード
   */
  readonly clientMode: ClientMode;
  /**
   * 場所
   */
  readonly location: Location;
  /**
   * 言語
   */
  readonly language: Language;
};

/**
 * デバッグモードか, リリースモード
 *  @typePartId 261b20a84f5b94b93559aaf98ffc6d33
 */
export type ClientMode = "DebugMode" | "Release";

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 *  @typePartId e830168583e34ff0750716aa6b253c5f
 */
export type Location =
  | { readonly _: "Home" }
  | { readonly _: "CreateProject" }
  | { readonly _: "Project"; readonly projectId: ProjectId }
  | { readonly _: "User"; readonly userId: UserId }
  | { readonly _: "Idea"; readonly ideaId: IdeaId }
  | { readonly _: "Suggestion"; readonly suggestionId: SuggestionId }
  | { readonly _: "About" }
  | { readonly _: "Debug" };

/**
 * 英語,日本語,エスペラント語などの言語
 *  @typePartId a7c52f1164c69f56625e8febd5f44bf3
 */
export type Language = "Japanese" | "English" | "Esperanto";

/**
 * ユーザーのデータのスナップショット
 *  @typePartId 655cea387d1aca74e54df4fc2888bcbb
 */
export type User = {
  /**
   * ユーザー名. 表示される名前. 他のユーザーとかぶっても良い. 絵文字も使える. 全角英数は半角英数,半角カタカナは全角カタカナ, (株)の合字を分解するなどのNFKCの正規化がされる. U+0000-U+0019 と U+007F-U+00A0 の範囲の文字は入らない. 前後に空白を含められない. 間の空白は2文字以上連続しない. 文字数のカウント方法は正規化されたあとのCodePoint単位. Twitterと同じ, 1文字以上50文字以下
   */
  readonly name: String;
  /**
   * プロフィール画像
   */
  readonly imageHash: ImageToken;
  /**
   * 自己紹介文. 改行文字を含めることができる. Twitterと同じ 0～160文字
   */
  readonly introduction: String;
  /**
   * Definyでユーザーが作成された日時
   */
  readonly createTime: Time;
  /**
   * プロジェクトに対する いいね
   */
  readonly likeProjectIdList: List<ProjectId>;
  /**
   * 開発に参加した (書いたコードが使われた) プロジェクト
   */
  readonly developProjectIdList: List<ProjectId>;
  /**
   * コメントをしたアイデア
   */
  readonly commentIdeaIdList: List<IdeaId>;
  /**
   * 取得日時
   */
  readonly getTime: Time;
};

/**
 * データを識別するIdとデータ
 *  @typePartId 12a442ac046b1757e8684652c2669450
 */
export type IdAndData<id extends unknown, data extends unknown> = {
  /**
   * ID
   */
  readonly id: id;
  /**
   * データ
   */
  readonly data: data;
};

/**
 * プロジェクト
 *  @typePartId 3fb93c7e94724891d2a224c6f945acbd
 */
export type Project = {
  /**
   * プロジェクト名
   */
  readonly name: String;
  /**
   * プロジェクトのアイコン画像
   */
  readonly iconHash: ImageToken;
  /**
   * プロジェクトのカバー画像
   */
  readonly imageHash: ImageToken;
  /**
   * 作成日時
   */
  readonly createTime: Time;
  /**
   * 作成アカウント
   */
  readonly createUserId: UserId;
  /**
   * 更新日時
   */
  readonly updateTime: Time;
  /**
   * 取得日時
   */
  readonly getTime: Time;
  /**
   * 所属しているのパーツのIDのリスト
   */
  readonly partIdList: List<PartId>;
  /**
   * 所属している型パーツのIDのリスト
   */
  readonly typePartIdList: List<TypePartId>;
};

/**
 * アイデア
 *  @typePartId 98d993c8105a292781e3d3291fb477b6
 */
export type Idea = {
  /**
   * アイデア名
   */
  readonly name: String;
  /**
   * 言い出しっぺ
   */
  readonly createUserId: UserId;
  /**
   * 作成日時
   */
  readonly createTime: Time;
  /**
   * 対象のプロジェクト
   */
  readonly projectId: ProjectId;
  /**
   * アイデアの要素
   */
  readonly itemList: List<IdeaItem>;
  /**
   * 更新日時
   */
  readonly updateTime: Time;
  /**
   * 取得日時
   */
  readonly getTime: Time;
};

/**
 * アイデアのコメント
 *  @typePartId ce630fa90ed090bd14c941915abd3293
 */
export type IdeaItem = {
  /**
   * 作成者
   */
  readonly createUserId: UserId;
  /**
   * 作成日時
   */
  readonly createTime: Time;
  /**
   * 本文
   */
  readonly body: IdeaItemBody;
};

/**
 * アイデアのアイテム
 *  @typePartId b88e52e998ab62764aa81c9940205668
 */
export type IdeaItemBody =
  | { readonly _: "Comment"; readonly string: String }
  | { readonly _: "SuggestionCreate"; readonly suggestionId: SuggestionId }
  | {
      readonly _: "SuggestionToApprovalPending";
      readonly suggestionId: SuggestionId;
    }
  | {
      readonly _: "SuggestionCancelToApprovalPending";
      readonly suggestionId: SuggestionId;
    }
  | { readonly _: "SuggestionApprove"; readonly suggestionId: SuggestionId }
  | { readonly _: "SuggestionReject"; readonly suggestionId: SuggestionId }
  | {
      readonly _: "SuggestionCancelRejection";
      readonly suggestionId: SuggestionId;
    };

/**
 * 提案
 *  @typePartId f16c59a2158d9642481085d2492007f8
 */
export type Suggestion = {
  /**
   * 変更概要
   */
  readonly name: String;
  /**
   * 作成者
   */
  readonly createUserId: UserId;
  /**
   * 変更理由
   */
  readonly reason: String;
  /**
   * 承認状態
   */
  readonly state: SuggestionId;
  /**
   * 変更
   */
  readonly changeList: List<Change>;
  /**
   * 変更をするプロジェクト
   */
  readonly projectId: ProjectId;
  /**
   * 投稿したアイデアID
   */
  readonly ideaId: IdeaId;
  /**
   * 更新日時
   */
  readonly updateTime: Time;
  /**
   * 取得日時
   */
  readonly getTime: Time;
};

/**
 * 提案の状況
 *  @typePartId 9b97c1996665f1009a2f5a0f334d6bff
 */
export type SuggestionState =
  | "Creating"
  | "ApprovalPending"
  | "Approved"
  | "Rejected";

/**
 * 変更点
 *  @typePartId e8a87ce7b719c048b40fa2c33263ff99
 */
export type Change = { readonly _: "ProjectName"; readonly string: String };

/**
 * 型パーツの識別子
 *  @typePartId 2562ffbc386c801f5132e10b945786e0
 */
export type TypePartId = string & { readonly _typePartId: never };

/**
 * コンパイラに向けた, 型のデータ形式をどうするかの情報
 *  @typePartId 225e93ce3e35aa0bd76d07ea6f6b89cf
 */
export type TypeAttribute = "AsBoolean";

/**
 * 型パラメーター
 *  @typePartId e1333f2af01621585b96e47aea9bfee1
 */
export type TypeParameter = {
  /**
   * 型パラメーターの名前
   */
  readonly name: String;
  /**
   * 型パラメーターの型ID
   */
  readonly typePartId: TypePartId;
};

/**
 * 型の定義本体
 *  @typePartId 27c027f90fb0fed86c8205cbd90cd08e
 */
export type TypePartBody =
  | { readonly _: "Product"; readonly memberList: List<Member> }
  | { readonly _: "Sum"; readonly patternList: List<Pattern> }
  | { readonly _: "Kernel"; readonly typePartBodyKernel: TypePartBodyKernel };

/**
 * 直積型のメンバー
 *  @typePartId 73b8e53686ac76acb085cb096f658d58
 */
export type Member = {
  /**
   * メンバー名
   */
  readonly name: String;
  /**
   * メンバーの説明
   */
  readonly description: String;
  /**
   * メンバー値の型
   */
  readonly type: Type;
};

/**
 * 直積型のパターン
 *  @typePartId 512c55527a1ce9822e1e51b2f6063789
 */
export type Pattern = {
  /**
   * タグ名
   */
  readonly name: String;
  /**
   * パターンの説明
   */
  readonly description: String;
  /**
   * そのパターンにつけるデータの型
   */
  readonly parameter: Maybe<Type>;
};

/**
 * Definyだけでは表現できないデータ型
 *  @typePartId 739fb46c7b45d8c51865fc91d5d2ebb1
 */
export type TypePartBodyKernel =
  | "Function"
  | "Int32"
  | "String"
  | "Binary"
  | "Id"
  | "Token"
  | "List";

/**
 * 型
 *  @typePartId 0e16754e227d7287a01596ee10e1244f
 */
export type Type = {
  /**
   * 型の参照
   */
  readonly typePartId: TypePartId;
  /**
   * 型のパラメーター
   */
  readonly parameter: List<Type>;
};

/**
 * プロジェクトの識別子
 *  @typePartId 4e3ab0f9499404a5fa100c4b57835906
 */
export type ProjectId = string & { readonly _projectId: never };

/**
 * ユーザーの識別子
 *  @typePartId 5a71cddc0b95298cb57ec66089190e9b
 */
export type UserId = string & { readonly _userId: never };

/**
 * アイデアの識別子
 *  @typePartId 719fa4020ae23a96d301d9fa31d8fcaf
 */
export type IdeaId = string & { readonly _ideaId: never };

/**
 * 提案の識別子
 *  @typePartId 72cc637f6803ef5ca7536889a7fff52e
 */
export type SuggestionId = string & { readonly _suggestionId: never };

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 *  @typePartId b193be207840b5b489517eb5d7b492b2
 */
export type ImageToken = string & { readonly _imageToken: never };

/**
 * パーツの識別子
 *  @typePartId d2c65983f602ee7e0a7be06e6af61acf
 */
export type PartId = string & { readonly _partId: never };

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 * @typePartId ccf22e92cea3639683c0271d65d00673
 */
export const Int32: { readonly codec: Codec<Int32> } = {
  codec: {
    encode: (value: Int32): ReadonlyArray<number> => {
      let rest: number = value | 0;
      const result: Array<number> = [];
      while (true) {
        const byte: number = rest & 127;
        rest >>= 7;
        if (
          (rest === 0 && (byte & 64) === 0) ||
          (rest === -1 && (byte & 64) !== 0)
        ) {
          result.push(byte);
          return result;
        }
        result.push(byte | 128);
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Int32; readonly nextIndex: number } => {
      let result: number = 0;
      let offset: number = 0;
      while (true) {
        const byte: number = binary[index + offset];
        result |= (byte & 127) << (offset * 7);
        offset += 1;
        if ((128 & byte) === 0) {
          if (offset * 7 < 32 && (byte & 64) !== 0) {
            return {
              result: result | (~0 << (offset * 7)),
              nextIndex: index + offset,
            };
          }
          return { result, nextIndex: index + offset };
        }
      }
    },
  },
};

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 * @typePartId 743d625544767e750c453fa344194599
 */
export const Binary: { readonly codec: Codec<Binary> } = {
  codec: {
    encode: (value: Binary): ReadonlyArray<number> =>
      Int32.codec.encode(value.length).concat([...value]),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Binary; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      return { result: binary.slice(length.nextIndex, nextIndex), nextIndex };
    },
  },
};

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 * @typePartId 93e91ed730b5e7689250a76096ae60a4
 */
export const Bool: {
  /**
   * 真
   */
  readonly True: Bool;
  /**
   * 偽
   */
  readonly False: Bool;
  readonly codec: Codec<Bool>;
} = {
  True: true,
  False: false,
  codec: {
    encode: (value: Bool): ReadonlyArray<number> => [value ? 1 : 0],
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Bool; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Bool.True, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Bool.False, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * リスト. JavaScriptのArrayで扱う
 * @typePartId d7a1efe440138793962eed5625de8196
 */
export const List: {
  readonly codec: <e extends unknown>(a: Codec<e>) => Codec<List<e>>;
} = {
  codec: <e extends unknown>(eCodec: Codec<e>): Codec<List<e>> => ({
    encode: (value: List<e>): ReadonlyArray<number> => {
      let result: Array<number> = Int32.codec.encode(value.length) as Array<
        number
      >;
      for (const element of value) {
        result = result.concat(eCodec.encode(element));
      }
      return result;
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: List<e>; readonly nextIndex: number } => {
      const lengthResult: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      let nextIndex: number = lengthResult.nextIndex;
      const result: Array<e> = [];
      for (let i = 0; i < lengthResult.result; i += 1) {
        const resultAndNextIndex: {
          readonly result: e;
          readonly nextIndex: number;
        } = eCodec.decode(nextIndex, binary);
        result.push(resultAndNextIndex.result);
        nextIndex = resultAndNextIndex.nextIndex;
      }
      return { result, nextIndex };
    },
  }),
};

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつける?
 * @typePartId cdd7dd74dd0f2036b44dcae6aaac46f5
 */
export const Maybe: {
  /**
   * 値があるということ
   */
  readonly Just: <value extends unknown>(a: value) => Maybe<value>;
  /**
   * 値がないということ
   */
  readonly Nothing: <value extends unknown>() => Maybe<value>;
  readonly codec: <value extends unknown>(
    a: Codec<value>
  ) => Codec<Maybe<value>>;
} = {
  Just: <value extends unknown>(value: value): Maybe<value> => ({
    _: "Just",
    value,
  }),
  Nothing: <value extends unknown>(): Maybe<value> => ({ _: "Nothing" }),
  codec: <value extends unknown>(
    valueCodec: Codec<value>
  ): Codec<Maybe<value>> => ({
    encode: (value: Maybe<value>): ReadonlyArray<number> => {
      switch (value._) {
        case "Just": {
          return [0].concat(valueCodec.encode(value.value));
        }
        case "Nothing": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Maybe<value>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: value;
          readonly nextIndex: number;
        } = valueCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Maybe.Just(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return { result: Maybe.Nothing(), nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 * @typePartId 943ef399d0891f897f26bc02fa24af70
 */
export const Result: {
  /**
   * 成功
   */
  readonly Ok: <ok extends unknown, error extends unknown>(
    a: ok
  ) => Result<ok, error>;
  /**
   * 失敗
   */
  readonly Error: <ok extends unknown, error extends unknown>(
    a: error
  ) => Result<ok, error>;
  readonly codec: <ok extends unknown, error extends unknown>(
    a: Codec<ok>,
    b: Codec<error>
  ) => Codec<Result<ok, error>>;
} = {
  Ok: <ok extends unknown, error extends unknown>(
    ok: ok
  ): Result<ok, error> => ({ _: "Ok", ok }),
  Error: <ok extends unknown, error extends unknown>(
    error: error
  ): Result<ok, error> => ({ _: "Error", error }),
  codec: <ok extends unknown, error extends unknown>(
    okCodec: Codec<ok>,
    errorCodec: Codec<error>
  ): Codec<Result<ok, error>> => ({
    encode: (value: Result<ok, error>): ReadonlyArray<number> => {
      switch (value._) {
        case "Ok": {
          return [0].concat(okCodec.encode(value.ok));
        }
        case "Error": {
          return [1].concat(errorCodec.encode(value.error));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Result<ok, error>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: ok;
          readonly nextIndex: number;
        } = okCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Ok(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: error;
          readonly nextIndex: number;
        } = errorCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Error(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 * @typePartId f1f830d23ffab8cec4d0191d157b9fc4
 */
export const String: { readonly codec: Codec<String> } = {
  codec: {
    encode: (value: String): ReadonlyArray<number> => {
      const result: ReadonlyArray<number> = [
        ...new (process === undefined || process.title === "browser"
          ? TextEncoder
          : a.TextEncoder)().encode(value),
      ];
      return Int32.codec.encode(result.length).concat(result);
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: String; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      const textBinary: Uint8Array = binary.slice(length.nextIndex, nextIndex);
      const isBrowser: boolean =
        process === undefined || process.title === "browser";
      if (isBrowser) {
        return { result: new TextDecoder().decode(textBinary), nextIndex };
      }
      return { result: new a.TextDecoder().decode(textBinary), nextIndex };
    },
  },
};

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 * @typePartId fa64c1721a3285f112a4118b66b43712
 */
export const Time: { readonly codec: Codec<Time> } = {
  codec: {
    encode: (value: Time): ReadonlyArray<number> =>
      Int32.codec
        .encode(value.day)
        .concat(Int32.codec.encode(value.millisecond)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Time; readonly nextIndex: number } => {
      const dayAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const millisecondAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(dayAndNextIndex.nextIndex, binary);
      return {
        result: {
          day: dayAndNextIndex.result,
          millisecond: millisecondAndNextIndex.result,
        },
        nextIndex: millisecondAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ログインのURLを発行するために必要なデータ
 * @typePartId db245392b9296a48a195e4bd8824dd2b
 */
export const RequestLogInUrlRequestData: {
  readonly codec: Codec<RequestLogInUrlRequestData>;
} = {
  codec: {
    encode: (value: RequestLogInUrlRequestData): ReadonlyArray<number> =>
      OpenIdConnectProvider.codec
        .encode(value.openIdConnectProvider)
        .concat(UrlData.codec.encode(value.urlData)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: RequestLogInUrlRequestData;
      readonly nextIndex: number;
    } => {
      const openIdConnectProviderAndNextIndex: {
        readonly result: OpenIdConnectProvider;
        readonly nextIndex: number;
      } = OpenIdConnectProvider.codec.decode(index, binary);
      const urlDataAndNextIndex: {
        readonly result: UrlData;
        readonly nextIndex: number;
      } = UrlData.codec.decode(
        openIdConnectProviderAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          openIdConnectProvider: openIdConnectProviderAndNextIndex.result,
          urlData: urlDataAndNextIndex.result,
        },
        nextIndex: urlDataAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 * @typePartId 0264130f1d9473f670907755cbee50d9
 */
export const OpenIdConnectProvider: {
  /**
   * Google ( https://developers.google.com/identity/sign-in/web/ )
   */
  readonly Google: OpenIdConnectProvider;
  /**
   * GitHub ( https://developer.github.com/v3/guides/basics-of-authentication/ )
   */
  readonly GitHub: OpenIdConnectProvider;
  readonly codec: Codec<OpenIdConnectProvider>;
} = {
  Google: "Google",
  GitHub: "GitHub",
  codec: {
    encode: (value: OpenIdConnectProvider): ReadonlyArray<number> => {
      switch (value) {
        case "Google": {
          return [0];
        }
        case "GitHub": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: OpenIdConnectProvider;
      readonly nextIndex: number;
    } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: OpenIdConnectProvider.Google,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: OpenIdConnectProvider.GitHub,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * デバッグモードかどうか,言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある. デバッグ時のホスト名は http://localhost になる
 * @typePartId dc3b3cd3f125b344fb60a91c0b184f3e
 */
export const UrlData: { readonly codec: Codec<UrlData> } = {
  codec: {
    encode: (value: UrlData): ReadonlyArray<number> =>
      ClientMode.codec
        .encode(value.clientMode)
        .concat(Location.codec.encode(value.location))
        .concat(Language.codec.encode(value.language)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UrlData; readonly nextIndex: number } => {
      const clientModeAndNextIndex: {
        readonly result: ClientMode;
        readonly nextIndex: number;
      } = ClientMode.codec.decode(index, binary);
      const locationAndNextIndex: {
        readonly result: Location;
        readonly nextIndex: number;
      } = Location.codec.decode(clientModeAndNextIndex.nextIndex, binary);
      const languageAndNextIndex: {
        readonly result: Language;
        readonly nextIndex: number;
      } = Language.codec.decode(locationAndNextIndex.nextIndex, binary);
      return {
        result: {
          clientMode: clientModeAndNextIndex.result,
          location: locationAndNextIndex.result,
          language: languageAndNextIndex.result,
        },
        nextIndex: languageAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * デバッグモードか, リリースモード
 * @typePartId 261b20a84f5b94b93559aaf98ffc6d33
 */
export const ClientMode: {
  /**
   * デバッグモード. オリジンは http://localshot:2520
   */
  readonly DebugMode: ClientMode;
  /**
   * リリースモード. オリジンは https://definy.app
   */
  readonly Release: ClientMode;
  readonly codec: Codec<ClientMode>;
} = {
  DebugMode: "DebugMode",
  Release: "Release",
  codec: {
    encode: (value: ClientMode): ReadonlyArray<number> => {
      switch (value) {
        case "DebugMode": {
          return [0];
        }
        case "Release": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ClientMode; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: ClientMode.DebugMode,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: ClientMode.Release,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 * @typePartId e830168583e34ff0750716aa6b253c5f
 */
export const Location: {
  /**
   * 最初のページ
   */
  readonly Home: Location;
  /**
   * プロジェクト作成画面
   */
  readonly CreateProject: Location;
  /**
   * プロジェクトの詳細ページ
   */
  readonly Project: (a: ProjectId) => Location;
  /**
   * ユーザーの詳細ページ
   */
  readonly User: (a: UserId) => Location;
  /**
   * アイデア詳細ページ
   */
  readonly Idea: (a: IdeaId) => Location;
  /**
   * 提案のページ
   */
  readonly Suggestion: (a: SuggestionId) => Location;
  /**
   * Definyについて説明したページ
   */
  readonly About: Location;
  /**
   * デバッグページ
   */
  readonly Debug: Location;
  readonly codec: Codec<Location>;
} = {
  Home: { _: "Home" },
  CreateProject: { _: "CreateProject" },
  Project: (projectId: ProjectId): Location => ({ _: "Project", projectId }),
  User: (userId: UserId): Location => ({ _: "User", userId }),
  Idea: (ideaId: IdeaId): Location => ({ _: "Idea", ideaId }),
  Suggestion: (suggestionId: SuggestionId): Location => ({
    _: "Suggestion",
    suggestionId,
  }),
  About: { _: "About" },
  Debug: { _: "Debug" },
  codec: {
    encode: (value: Location): ReadonlyArray<number> => {
      switch (value._) {
        case "Home": {
          return [0];
        }
        case "CreateProject": {
          return [1];
        }
        case "Project": {
          return [2].concat(ProjectId.codec.encode(value.projectId));
        }
        case "User": {
          return [3].concat(UserId.codec.encode(value.userId));
        }
        case "Idea": {
          return [4].concat(IdeaId.codec.encode(value.ideaId));
        }
        case "Suggestion": {
          return [5].concat(SuggestionId.codec.encode(value.suggestionId));
        }
        case "About": {
          return [6];
        }
        case "Debug": {
          return [7];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Location; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Location.Home, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return {
          result: Location.CreateProject,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: ProjectId;
          readonly nextIndex: number;
        } = ProjectId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Project(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: UserId;
          readonly nextIndex: number;
        } = UserId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.User(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        const result: {
          readonly result: IdeaId;
          readonly nextIndex: number;
        } = IdeaId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Idea(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        const result: {
          readonly result: SuggestionId;
          readonly nextIndex: number;
        } = SuggestionId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Suggestion(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        return { result: Location.About, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 7) {
        return { result: Location.Debug, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 英語,日本語,エスペラント語などの言語
 * @typePartId a7c52f1164c69f56625e8febd5f44bf3
 */
export const Language: {
  /**
   * 日本語
   */
  readonly Japanese: Language;
  /**
   * 英語
   */
  readonly English: Language;
  /**
   * エスペラント語
   */
  readonly Esperanto: Language;
  readonly codec: Codec<Language>;
} = {
  Japanese: "Japanese",
  English: "English",
  Esperanto: "Esperanto",
  codec: {
    encode: (value: Language): ReadonlyArray<number> => {
      switch (value) {
        case "Japanese": {
          return [0];
        }
        case "English": {
          return [1];
        }
        case "Esperanto": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Language; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Language.Japanese, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Language.English, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 2) {
        return {
          result: Language.Esperanto,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * ユーザーのデータのスナップショット
 * @typePartId 655cea387d1aca74e54df4fc2888bcbb
 */
export const User: { readonly codec: Codec<User> } = {
  codec: {
    encode: (value: User): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(ImageToken.codec.encode(value.imageHash))
        .concat(String.codec.encode(value.introduction))
        .concat(Time.codec.encode(value.createTime))
        .concat(List.codec(ProjectId.codec).encode(value.likeProjectIdList))
        .concat(List.codec(ProjectId.codec).encode(value.developProjectIdList))
        .concat(List.codec(IdeaId.codec).encode(value.commentIdeaIdList))
        .concat(Time.codec.encode(value.getTime)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: User; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const imageHashAndNextIndex: {
        readonly result: ImageToken;
        readonly nextIndex: number;
      } = ImageToken.codec.decode(nameAndNextIndex.nextIndex, binary);
      const introductionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(imageHashAndNextIndex.nextIndex, binary);
      const createTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(introductionAndNextIndex.nextIndex, binary);
      const likeProjectIdListAndNextIndex: {
        readonly result: List<ProjectId>;
        readonly nextIndex: number;
      } = List.codec(ProjectId.codec).decode(
        createTimeAndNextIndex.nextIndex,
        binary
      );
      const developProjectIdListAndNextIndex: {
        readonly result: List<ProjectId>;
        readonly nextIndex: number;
      } = List.codec(ProjectId.codec).decode(
        likeProjectIdListAndNextIndex.nextIndex,
        binary
      );
      const commentIdeaIdListAndNextIndex: {
        readonly result: List<IdeaId>;
        readonly nextIndex: number;
      } = List.codec(IdeaId.codec).decode(
        developProjectIdListAndNextIndex.nextIndex,
        binary
      );
      const getTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(commentIdeaIdListAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          imageHash: imageHashAndNextIndex.result,
          introduction: introductionAndNextIndex.result,
          createTime: createTimeAndNextIndex.result,
          likeProjectIdList: likeProjectIdListAndNextIndex.result,
          developProjectIdList: developProjectIdListAndNextIndex.result,
          commentIdeaIdList: commentIdeaIdListAndNextIndex.result,
          getTime: getTimeAndNextIndex.result,
        },
        nextIndex: getTimeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * データを識別するIdとデータ
 * @typePartId 12a442ac046b1757e8684652c2669450
 */
export const IdAndData: {
  readonly codec: <id extends unknown, data extends unknown>(
    a: Codec<id>,
    b: Codec<data>
  ) => Codec<IdAndData<id, data>>;
} = {
  codec: <id extends unknown, data extends unknown>(
    idCodec: Codec<id>,
    dataCodec: Codec<data>
  ): Codec<IdAndData<id, data>> => ({
    encode: (value: IdAndData<id, data>): ReadonlyArray<number> =>
      idCodec.encode(value.id).concat(dataCodec.encode(value.data)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IdAndData<id, data>; readonly nextIndex: number } => {
      const idAndNextIndex: {
        readonly result: id;
        readonly nextIndex: number;
      } = idCodec.decode(index, binary);
      const dataAndNextIndex: {
        readonly result: data;
        readonly nextIndex: number;
      } = dataCodec.decode(idAndNextIndex.nextIndex, binary);
      return {
        result: { id: idAndNextIndex.result, data: dataAndNextIndex.result },
        nextIndex: dataAndNextIndex.nextIndex,
      };
    },
  }),
};

/**
 * プロジェクト
 * @typePartId 3fb93c7e94724891d2a224c6f945acbd
 */
export const Project: { readonly codec: Codec<Project> } = {
  codec: {
    encode: (value: Project): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(ImageToken.codec.encode(value.iconHash))
        .concat(ImageToken.codec.encode(value.imageHash))
        .concat(Time.codec.encode(value.createTime))
        .concat(UserId.codec.encode(value.createUserId))
        .concat(Time.codec.encode(value.updateTime))
        .concat(Time.codec.encode(value.getTime))
        .concat(List.codec(PartId.codec).encode(value.partIdList))
        .concat(List.codec(TypePartId.codec).encode(value.typePartIdList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Project; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const iconHashAndNextIndex: {
        readonly result: ImageToken;
        readonly nextIndex: number;
      } = ImageToken.codec.decode(nameAndNextIndex.nextIndex, binary);
      const imageHashAndNextIndex: {
        readonly result: ImageToken;
        readonly nextIndex: number;
      } = ImageToken.codec.decode(iconHashAndNextIndex.nextIndex, binary);
      const createTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(imageHashAndNextIndex.nextIndex, binary);
      const createUserIdAndNextIndex: {
        readonly result: UserId;
        readonly nextIndex: number;
      } = UserId.codec.decode(createTimeAndNextIndex.nextIndex, binary);
      const updateTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(createUserIdAndNextIndex.nextIndex, binary);
      const getTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(updateTimeAndNextIndex.nextIndex, binary);
      const partIdListAndNextIndex: {
        readonly result: List<PartId>;
        readonly nextIndex: number;
      } = List.codec(PartId.codec).decode(
        getTimeAndNextIndex.nextIndex,
        binary
      );
      const typePartIdListAndNextIndex: {
        readonly result: List<TypePartId>;
        readonly nextIndex: number;
      } = List.codec(TypePartId.codec).decode(
        partIdListAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          iconHash: iconHashAndNextIndex.result,
          imageHash: imageHashAndNextIndex.result,
          createTime: createTimeAndNextIndex.result,
          createUserId: createUserIdAndNextIndex.result,
          updateTime: updateTimeAndNextIndex.result,
          getTime: getTimeAndNextIndex.result,
          partIdList: partIdListAndNextIndex.result,
          typePartIdList: typePartIdListAndNextIndex.result,
        },
        nextIndex: typePartIdListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アイデア
 * @typePartId 98d993c8105a292781e3d3291fb477b6
 */
export const Idea: { readonly codec: Codec<Idea> } = {
  codec: {
    encode: (value: Idea): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(UserId.codec.encode(value.createUserId))
        .concat(Time.codec.encode(value.createTime))
        .concat(ProjectId.codec.encode(value.projectId))
        .concat(List.codec(IdeaItem.codec).encode(value.itemList))
        .concat(Time.codec.encode(value.updateTime))
        .concat(Time.codec.encode(value.getTime)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Idea; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const createUserIdAndNextIndex: {
        readonly result: UserId;
        readonly nextIndex: number;
      } = UserId.codec.decode(nameAndNextIndex.nextIndex, binary);
      const createTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(createUserIdAndNextIndex.nextIndex, binary);
      const projectIdAndNextIndex: {
        readonly result: ProjectId;
        readonly nextIndex: number;
      } = ProjectId.codec.decode(createTimeAndNextIndex.nextIndex, binary);
      const itemListAndNextIndex: {
        readonly result: List<IdeaItem>;
        readonly nextIndex: number;
      } = List.codec(IdeaItem.codec).decode(
        projectIdAndNextIndex.nextIndex,
        binary
      );
      const updateTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(itemListAndNextIndex.nextIndex, binary);
      const getTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(updateTimeAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          createUserId: createUserIdAndNextIndex.result,
          createTime: createTimeAndNextIndex.result,
          projectId: projectIdAndNextIndex.result,
          itemList: itemListAndNextIndex.result,
          updateTime: updateTimeAndNextIndex.result,
          getTime: getTimeAndNextIndex.result,
        },
        nextIndex: getTimeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アイデアのコメント
 * @typePartId ce630fa90ed090bd14c941915abd3293
 */
export const IdeaItem: { readonly codec: Codec<IdeaItem> } = {
  codec: {
    encode: (value: IdeaItem): ReadonlyArray<number> =>
      UserId.codec
        .encode(value.createUserId)
        .concat(Time.codec.encode(value.createTime))
        .concat(IdeaItemBody.codec.encode(value.body)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IdeaItem; readonly nextIndex: number } => {
      const createUserIdAndNextIndex: {
        readonly result: UserId;
        readonly nextIndex: number;
      } = UserId.codec.decode(index, binary);
      const createTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(createUserIdAndNextIndex.nextIndex, binary);
      const bodyAndNextIndex: {
        readonly result: IdeaItemBody;
        readonly nextIndex: number;
      } = IdeaItemBody.codec.decode(createTimeAndNextIndex.nextIndex, binary);
      return {
        result: {
          createUserId: createUserIdAndNextIndex.result,
          createTime: createTimeAndNextIndex.result,
          body: bodyAndNextIndex.result,
        },
        nextIndex: bodyAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アイデアのアイテム
 * @typePartId b88e52e998ab62764aa81c9940205668
 */
export const IdeaItemBody: {
  /**
   * 文章でのコメントをした
   */
  readonly Comment: (a: String) => IdeaItemBody;
  /**
   * 提案を作成した
   */
  readonly SuggestionCreate: (a: SuggestionId) => IdeaItemBody;
  /**
   * 提案を承認待ちにした
   */
  readonly SuggestionToApprovalPending: (a: SuggestionId) => IdeaItemBody;
  /**
   * 承認待ちをキャンセルした
   */
  readonly SuggestionCancelToApprovalPending: (a: SuggestionId) => IdeaItemBody;
  /**
   * 提案を承認した
   */
  readonly SuggestionApprove: (a: SuggestionId) => IdeaItemBody;
  /**
   * 提案を拒否した
   */
  readonly SuggestionReject: (a: SuggestionId) => IdeaItemBody;
  /**
   * 提案の拒否をキャンセルした
   */
  readonly SuggestionCancelRejection: (a: SuggestionId) => IdeaItemBody;
  readonly codec: Codec<IdeaItemBody>;
} = {
  Comment: (string_: String): IdeaItemBody => ({
    _: "Comment",
    string: string_,
  }),
  SuggestionCreate: (suggestionId: SuggestionId): IdeaItemBody => ({
    _: "SuggestionCreate",
    suggestionId,
  }),
  SuggestionToApprovalPending: (suggestionId: SuggestionId): IdeaItemBody => ({
    _: "SuggestionToApprovalPending",
    suggestionId,
  }),
  SuggestionCancelToApprovalPending: (
    suggestionId: SuggestionId
  ): IdeaItemBody => ({ _: "SuggestionCancelToApprovalPending", suggestionId }),
  SuggestionApprove: (suggestionId: SuggestionId): IdeaItemBody => ({
    _: "SuggestionApprove",
    suggestionId,
  }),
  SuggestionReject: (suggestionId: SuggestionId): IdeaItemBody => ({
    _: "SuggestionReject",
    suggestionId,
  }),
  SuggestionCancelRejection: (suggestionId: SuggestionId): IdeaItemBody => ({
    _: "SuggestionCancelRejection",
    suggestionId,
  }),
  codec: {
    encode: (value: IdeaItemBody): ReadonlyArray<number> => {
      switch (value._) {
        case "Comment": {
          return [0].concat(String.codec.encode(value.string));
        }
        case "SuggestionCreate": {
          return [1].concat(SuggestionId.codec.encode(value.suggestionId));
        }
        case "SuggestionToApprovalPending": {
          return [2].concat(SuggestionId.codec.encode(value.suggestionId));
        }
        case "SuggestionCancelToApprovalPending": {
          return [3].concat(SuggestionId.codec.encode(value.suggestionId));
        }
        case "SuggestionApprove": {
          return [4].concat(SuggestionId.codec.encode(value.suggestionId));
        }
        case "SuggestionReject": {
          return [5].concat(SuggestionId.codec.encode(value.suggestionId));
        }
        case "SuggestionCancelRejection": {
          return [6].concat(SuggestionId.codec.encode(value.suggestionId));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IdeaItemBody; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: IdeaItemBody.Comment(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: SuggestionId;
          readonly nextIndex: number;
        } = SuggestionId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: IdeaItemBody.SuggestionCreate(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: SuggestionId;
          readonly nextIndex: number;
        } = SuggestionId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: IdeaItemBody.SuggestionToApprovalPending(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: SuggestionId;
          readonly nextIndex: number;
        } = SuggestionId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: IdeaItemBody.SuggestionCancelToApprovalPending(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        const result: {
          readonly result: SuggestionId;
          readonly nextIndex: number;
        } = SuggestionId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: IdeaItemBody.SuggestionApprove(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        const result: {
          readonly result: SuggestionId;
          readonly nextIndex: number;
        } = SuggestionId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: IdeaItemBody.SuggestionReject(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        const result: {
          readonly result: SuggestionId;
          readonly nextIndex: number;
        } = SuggestionId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: IdeaItemBody.SuggestionCancelRejection(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 提案
 * @typePartId f16c59a2158d9642481085d2492007f8
 */
export const Suggestion: { readonly codec: Codec<Suggestion> } = {
  codec: {
    encode: (value: Suggestion): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(UserId.codec.encode(value.createUserId))
        .concat(String.codec.encode(value.reason))
        .concat(SuggestionId.codec.encode(value.state))
        .concat(List.codec(Change.codec).encode(value.changeList))
        .concat(ProjectId.codec.encode(value.projectId))
        .concat(IdeaId.codec.encode(value.ideaId))
        .concat(Time.codec.encode(value.updateTime))
        .concat(Time.codec.encode(value.getTime)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Suggestion; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const createUserIdAndNextIndex: {
        readonly result: UserId;
        readonly nextIndex: number;
      } = UserId.codec.decode(nameAndNextIndex.nextIndex, binary);
      const reasonAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(createUserIdAndNextIndex.nextIndex, binary);
      const stateAndNextIndex: {
        readonly result: SuggestionId;
        readonly nextIndex: number;
      } = SuggestionId.codec.decode(reasonAndNextIndex.nextIndex, binary);
      const changeListAndNextIndex: {
        readonly result: List<Change>;
        readonly nextIndex: number;
      } = List.codec(Change.codec).decode(stateAndNextIndex.nextIndex, binary);
      const projectIdAndNextIndex: {
        readonly result: ProjectId;
        readonly nextIndex: number;
      } = ProjectId.codec.decode(changeListAndNextIndex.nextIndex, binary);
      const ideaIdAndNextIndex: {
        readonly result: IdeaId;
        readonly nextIndex: number;
      } = IdeaId.codec.decode(projectIdAndNextIndex.nextIndex, binary);
      const updateTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(ideaIdAndNextIndex.nextIndex, binary);
      const getTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(updateTimeAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          createUserId: createUserIdAndNextIndex.result,
          reason: reasonAndNextIndex.result,
          state: stateAndNextIndex.result,
          changeList: changeListAndNextIndex.result,
          projectId: projectIdAndNextIndex.result,
          ideaId: ideaIdAndNextIndex.result,
          updateTime: updateTimeAndNextIndex.result,
          getTime: getTimeAndNextIndex.result,
        },
        nextIndex: getTimeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 提案の状況
 * @typePartId 9b97c1996665f1009a2f5a0f334d6bff
 */
export const SuggestionState: {
  /**
   * 作成中
   */
  readonly Creating: SuggestionState;
  /**
   * 承認待ち
   */
  readonly ApprovalPending: SuggestionState;
  /**
   * 承認済み
   */
  readonly Approved: SuggestionState;
  /**
   * 拒否された
   */
  readonly Rejected: SuggestionState;
  readonly codec: Codec<SuggestionState>;
} = {
  Creating: "Creating",
  ApprovalPending: "ApprovalPending",
  Approved: "Approved",
  Rejected: "Rejected",
  codec: {
    encode: (value: SuggestionState): ReadonlyArray<number> => {
      switch (value) {
        case "Creating": {
          return [0];
        }
        case "ApprovalPending": {
          return [1];
        }
        case "Approved": {
          return [2];
        }
        case "Rejected": {
          return [3];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: SuggestionState; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: SuggestionState.Creating,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: SuggestionState.ApprovalPending,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: SuggestionState.Approved,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: SuggestionState.Rejected,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 変更点
 * @typePartId e8a87ce7b719c048b40fa2c33263ff99
 */
export const Change: {
  /**
   * プロジェクト名の変更
   */
  readonly ProjectName: (a: String) => Change;
  readonly codec: Codec<Change>;
} = {
  ProjectName: (string_: String): Change => ({
    _: "ProjectName",
    string: string_,
  }),
  codec: {
    encode: (value: Change): ReadonlyArray<number> => {
      switch (value._) {
        case "ProjectName": {
          return [0].concat(String.codec.encode(value.string));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Change; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Change.ProjectName(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 型パーツの識別子
 * @typePartId 2562ffbc386c801f5132e10b945786e0
 */
export const TypePartId: { readonly codec: Codec<TypePartId> } = {
  codec: {
    encode: (value: TypePartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: TypePartId;
        readonly nextIndex: number;
      },
  },
};

/**
 * コンパイラに向けた, 型のデータ形式をどうするかの情報
 * @typePartId 225e93ce3e35aa0bd76d07ea6f6b89cf
 */
export const TypeAttribute: {
  /**
   * JavaScriptのbooleanとしれ扱うように指示する. 定義が True | Falseのような形のみをサポートする
   */
  readonly AsBoolean: TypeAttribute;
  readonly codec: Codec<TypeAttribute>;
} = {
  AsBoolean: "AsBoolean",
  codec: {
    encode: (value: TypeAttribute): ReadonlyArray<number> => {
      switch (value) {
        case "AsBoolean": {
          return [0];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypeAttribute; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: TypeAttribute.AsBoolean,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 型パラメーター
 * @typePartId e1333f2af01621585b96e47aea9bfee1
 */
export const TypeParameter: { readonly codec: Codec<TypeParameter> } = {
  codec: {
    encode: (value: TypeParameter): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(TypePartId.codec.encode(value.typePartId)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypeParameter; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const typePartIdAndNextIndex: {
        readonly result: TypePartId;
        readonly nextIndex: number;
      } = TypePartId.codec.decode(nameAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          typePartId: typePartIdAndNextIndex.result,
        },
        nextIndex: typePartIdAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 型の定義本体
 * @typePartId 27c027f90fb0fed86c8205cbd90cd08e
 */
export const TypePartBody: {
  /**
   * 直積型
   */
  readonly Product: (a: List<Member>) => TypePartBody;
  /**
   * 直和型
   */
  readonly Sum: (a: List<Pattern>) => TypePartBody;
  /**
   * Definyだけでは表現できないデータ型
   */
  readonly Kernel: (a: TypePartBodyKernel) => TypePartBody;
  readonly codec: Codec<TypePartBody>;
} = {
  Product: (memberList: List<Member>): TypePartBody => ({
    _: "Product",
    memberList,
  }),
  Sum: (patternList: List<Pattern>): TypePartBody => ({
    _: "Sum",
    patternList,
  }),
  Kernel: (typePartBodyKernel: TypePartBodyKernel): TypePartBody => ({
    _: "Kernel",
    typePartBodyKernel,
  }),
  codec: {
    encode: (value: TypePartBody): ReadonlyArray<number> => {
      switch (value._) {
        case "Product": {
          return [0].concat(List.codec(Member.codec).encode(value.memberList));
        }
        case "Sum": {
          return [1].concat(
            List.codec(Pattern.codec).encode(value.patternList)
          );
        }
        case "Kernel": {
          return [2].concat(
            TypePartBodyKernel.codec.encode(value.typePartBodyKernel)
          );
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartBody; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: List<Member>;
          readonly nextIndex: number;
        } = List.codec(Member.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: TypePartBody.Product(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: List<Pattern>;
          readonly nextIndex: number;
        } = List.codec(Pattern.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: TypePartBody.Sum(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: TypePartBodyKernel;
          readonly nextIndex: number;
        } = TypePartBodyKernel.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TypePartBody.Kernel(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 直積型のメンバー
 * @typePartId 73b8e53686ac76acb085cb096f658d58
 */
export const Member: { readonly codec: Codec<Member> } = {
  codec: {
    encode: (value: Member): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(String.codec.encode(value.description))
        .concat(Type.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Member; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const descriptionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(descriptionAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          description: descriptionAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 直積型のパターン
 * @typePartId 512c55527a1ce9822e1e51b2f6063789
 */
export const Pattern: { readonly codec: Codec<Pattern> } = {
  codec: {
    encode: (value: Pattern): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(String.codec.encode(value.description))
        .concat(Maybe.codec(Type.codec).encode(value.parameter)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Pattern; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const descriptionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const parameterAndNextIndex: {
        readonly result: Maybe<Type>;
        readonly nextIndex: number;
      } = Maybe.codec(Type.codec).decode(
        descriptionAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          description: descriptionAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
        },
        nextIndex: parameterAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Definyだけでは表現できないデータ型
 * @typePartId 739fb46c7b45d8c51865fc91d5d2ebb1
 */
export const TypePartBodyKernel: {
  /**
   * 関数
   */
  readonly Function: TypePartBodyKernel;
  /**
   * 32bit整数
   */
  readonly Int32: TypePartBodyKernel;
  /**
   * 文字列. Definyだけで表現できるが, TypeScriptでstringとして扱うために必要
   */
  readonly String: TypePartBodyKernel;
  /**
   * バイナリ型. TypeScriptではUint8Arrayとして扱う
   */
  readonly Binary: TypePartBodyKernel;
  /**
   * UUID (16byte) を表現する. 内部表現はとりあえず0-f長さ32の文字列
   */
  readonly Id: TypePartBodyKernel;
  /**
   * sha256などでハッシュ化したもの (32byte) を表現する. 内部表現はとりあえず0-f長さ64の文字列
   */
  readonly Token: TypePartBodyKernel;
  /**
   * 配列型. TypeScriptではReadonlyArrayとして扱う
   */
  readonly List: TypePartBodyKernel;
  readonly codec: Codec<TypePartBodyKernel>;
} = {
  Function: "Function",
  Int32: "Int32",
  String: "String",
  Binary: "Binary",
  Id: "Id",
  Token: "Token",
  List: "List",
  codec: {
    encode: (value: TypePartBodyKernel): ReadonlyArray<number> => {
      switch (value) {
        case "Function": {
          return [0];
        }
        case "Int32": {
          return [1];
        }
        case "String": {
          return [2];
        }
        case "Binary": {
          return [3];
        }
        case "Id": {
          return [4];
        }
        case "Token": {
          return [5];
        }
        case "List": {
          return [6];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartBodyKernel; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: TypePartBodyKernel.Function,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: TypePartBodyKernel.Int32,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: TypePartBodyKernel.String,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: TypePartBodyKernel.Binary,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return {
          result: TypePartBodyKernel.Id,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        return {
          result: TypePartBodyKernel.Token,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        return {
          result: TypePartBodyKernel.List,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 型
 * @typePartId 0e16754e227d7287a01596ee10e1244f
 */
export const Type: { readonly codec: Codec<Type> } = {
  codec: {
    encode: (value: Type): ReadonlyArray<number> =>
      TypePartId.codec
        .encode(value.typePartId)
        .concat(List.codec(Type.codec).encode(value.parameter)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Type; readonly nextIndex: number } => {
      const typePartIdAndNextIndex: {
        readonly result: TypePartId;
        readonly nextIndex: number;
      } = TypePartId.codec.decode(index, binary);
      const parameterAndNextIndex: {
        readonly result: List<Type>;
        readonly nextIndex: number;
      } = List.codec(Type.codec).decode(
        typePartIdAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          typePartId: typePartIdAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
        },
        nextIndex: parameterAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * プロジェクトの識別子
 * @typePartId 4e3ab0f9499404a5fa100c4b57835906
 */
export const ProjectId: { readonly codec: Codec<ProjectId> } = {
  codec: {
    encode: (value: ProjectId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ProjectId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: ProjectId;
        readonly nextIndex: number;
      },
  },
};

/**
 * ユーザーの識別子
 * @typePartId 5a71cddc0b95298cb57ec66089190e9b
 */
export const UserId: { readonly codec: Codec<UserId> } = {
  codec: {
    encode: (value: UserId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UserId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: UserId;
        readonly nextIndex: number;
      },
  },
};

/**
 * アイデアの識別子
 * @typePartId 719fa4020ae23a96d301d9fa31d8fcaf
 */
export const IdeaId: { readonly codec: Codec<IdeaId> } = {
  codec: {
    encode: (value: IdeaId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IdeaId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: IdeaId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 提案の識別子
 * @typePartId 72cc637f6803ef5ca7536889a7fff52e
 */
export const SuggestionId: { readonly codec: Codec<SuggestionId> } = {
  codec: {
    encode: (value: SuggestionId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: SuggestionId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: SuggestionId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 * @typePartId b193be207840b5b489517eb5d7b492b2
 */
export const ImageToken: { readonly codec: Codec<ImageToken> } = {
  codec: {
    encode: (value: ImageToken): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImageToken; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: ImageToken;
        readonly nextIndex: number;
      },
  },
};

/**
 * パーツの識別子
 * @typePartId d2c65983f602ee7e0a7be06e6af61acf
 */
export const PartId: { readonly codec: Codec<PartId> } = {
  codec: {
    encode: (value: PartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: PartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: PartId;
        readonly nextIndex: number;
      },
  },
};

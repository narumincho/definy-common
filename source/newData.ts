/* eslint-disable */
/* generated by js-ts-code-generator. Do not edit! */

import * as a from "util";

/**
 * UserId, ProjectIdなどのIdをバイナリ形式にエンコードする
 */
export const encodeId = (value: string): ReadonlyArray<number> => {
  const result: Array<number> = [];
  for (let i = 0; i < 16; i += 1) {
    result[i] = Number.parseInt(value.slice(i * 2, i * 2 + 2), 16);
  }
  return result;
};

/**
 * バイナリ形式をUserId, ProjectIdなどのIdにデコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeId = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 16)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 16,
});

/**
 * ImageTokenなどのTokenをバイナリ形式にエンコードする
 */
export const encodeToken = (value: string): ReadonlyArray<number> => {
  const result: Array<number> = [];
  for (let i = 0; i < 32; i += 1) {
    result[i] = Number.parseInt(value.slice(i * 2, i * 2 + 2), 16);
  }
  return result;
};

/**
 * バイナリ形式をImageTokenなどのTokenにエンコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeToken = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 32)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 32,
});

/**
 * バイナリと相互変換するための関数
 */
export type Codec<T extends unknown> = {
  readonly encode: (a: T) => ReadonlyArray<number>;
  readonly decode: (
    a: number,
    b: Uint8Array
  ) => { readonly result: T; readonly nextIndex: number };
};

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 *  @typePartId ccf22e92cea3639683c0271d65d00673
 */
export type Int32 = number;

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 *  @typePartId 743d625544767e750c453fa344194599
 */
export type Binary = Uint8Array;

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 *  @typePartId 93e91ed730b5e7689250a76096ae60a4
 */
export type Bool = boolean;

/**
 * リスト. JavaScriptのArrayで扱う
 *  @typePartId d7a1efe440138793962eed5625de8196
 */
export type List<e extends unknown> = ReadonlyArray<e>;

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつける?
 *  @typePartId cdd7dd74dd0f2036b44dcae6aaac46f5
 */
export type Maybe<value extends unknown> =
  | { readonly _: "Just"; readonly value: value }
  | { readonly _: "Nothing" };

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 *  @typePartId 943ef399d0891f897f26bc02fa24af70
 */
export type Result<ok extends unknown, error extends unknown> =
  | { readonly _: "Ok"; readonly ok: ok }
  | { readonly _: "Error"; readonly error: error };

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 *  @typePartId f1f830d23ffab8cec4d0191d157b9fc4
 */
export type String = string;

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 *  @typePartId fa64c1721a3285f112a4118b66b43712
 */
export type Time = {
  /**
   * 1970-01-01からの経過日数. マイナスになることもある
   */
  readonly day: Int32;
  /**
   * 日にちの中のミリ秒. 0 to 86399999 (=1000*60*60*24-1)
   */
  readonly millisecond: Int32;
};

/**
 * ログインのURLを発行するために必要なデータ
 *  @typePartId db245392b9296a48a195e4bd8824dd2b
 */
export type RequestLogInUrlRequestData = {
  /**
   * ログインに使用するプロバイダー
   */
  readonly openIdConnectProvider: OpenIdConnectProvider;
  /**
   * ログインした後に返ってくるURLに必要なデータ
   */
  readonly urlData: UrlData;
};

/**
 * ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 *  @typePartId 0264130f1d9473f670907755cbee50d9
 */
export type OpenIdConnectProvider = "Google" | "GitHub";

/**
 * デバッグモードかどうか,言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある. デバッグ時のホスト名は http://localhost になる
 *  @typePartId dc3b3cd3f125b344fb60a91c0b184f3e
 */
export type UrlData = {
  /**
   * クライアントモード
   */
  readonly clientMode: ClientMode;
  /**
   * 場所
   */
  readonly location: Location;
  /**
   * 言語
   */
  readonly language: Language;
};

/**
 * デバッグモードか, リリースモード
 *  @typePartId 261b20a84f5b94b93559aaf98ffc6d33
 */
export type ClientMode = "DebugMode" | "Release";

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 *  @typePartId e830168583e34ff0750716aa6b253c5f
 */
export type Location =
  | { readonly _: "Home" }
  | { readonly _: "CreateProject" }
  | { readonly _: "Project"; readonly projectId: ProjectId }
  | { readonly _: "User"; readonly userId: UserId }
  | { readonly _: "Idea"; readonly ideaId: IdeaId }
  | { readonly _: "Suggestion"; readonly suggestionId: SuggestionId }
  | { readonly _: "About" }
  | { readonly _: "Debug" };

/**
 * 英語,日本語,エスペラント語などの言語
 *  @typePartId a7c52f1164c69f56625e8febd5f44bf3
 */
export type Language = "Japanese" | "English" | "Esperanto";

/**
 * ユーザーのデータのスナップショット
 *  @typePartId 655cea387d1aca74e54df4fc2888bcbb
 */
export type User = {
  /**
   * ユーザー名. 表示される名前. 他のユーザーとかぶっても良い. 絵文字も使える. 全角英数は半角英数,半角カタカナは全角カタカナ, (株)の合字を分解するなどのNFKCの正規化がされる. U+0000-U+0019 と U+007F-U+00A0 の範囲の文字は入らない. 前後に空白を含められない. 間の空白は2文字以上連続しない. 文字数のカウント方法は正規化されたあとのCodePoint単位. Twitterと同じ, 1文字以上50文字以下
   */
  readonly name: String;
  /**
   * プロフィール画像
   */
  readonly imageHash: ImageToken;
  /**
   * 自己紹介文. 改行文字を含めることができる. Twitterと同じ 0～160文字
   */
  readonly introduction: String;
  /**
   * Definyでユーザーが作成された日時
   */
  readonly createTime: Time;
  /**
   * プロジェクトに対する いいね
   */
  readonly likeProjectIdList: List<ProjectId>;
  /**
   * 開発に参加した (書いたコードが使われた) プロジェクト
   */
  readonly developProjectIdList: List<ProjectId>;
  /**
   * コメントをしたアイデア
   */
  readonly commentIdeaIdList: List<IdeaId>;
  /**
   * 取得日時
   */
  readonly getTime: Time;
};

/**
 * データを識別するIdとデータ
 *  @typePartId 12a442ac046b1757e8684652c2669450
 */
export type IdAndData<id extends unknown, data extends unknown> = {
  /**
   * ID
   */
  readonly id: id;
  /**
   * データ
   */
  readonly data: data;
};

/**
 * プロジェクト
 *  @typePartId 3fb93c7e94724891d2a224c6f945acbd
 */
export type Project = {
  /**
   * プロジェクト名
   */
  readonly name: String;
  /**
   * プロジェクトのアイコン画像
   */
  readonly iconHash: ImageToken;
  /**
   * プロジェクトのカバー画像
   */
  readonly imageHash: ImageToken;
  /**
   * 作成日時
   */
  readonly createTime: Time;
  /**
   * 作成アカウント
   */
  readonly createUserId: UserId;
  /**
   * 更新日時
   */
  readonly updateTime: Time;
  /**
   * 取得日時
   */
  readonly getTime: Time;
  /**
   * 所属しているのパーツのIDのリスト
   */
  readonly partIdList: List<PartId>;
  /**
   * 所属している型パーツのIDのリスト
   */
  readonly typePartIdList: List<TypePartId>;
};

/**
 * プロジェクトの識別子
 *  @typePartId 4e3ab0f9499404a5fa100c4b57835906
 */
export type ProjectId = string & { readonly _projectId: never };

/**
 * ユーザーの識別子
 *  @typePartId 5a71cddc0b95298cb57ec66089190e9b
 */
export type UserId = string & { readonly _userId: never };

/**
 * アイデアの識別子
 *  @typePartId 719fa4020ae23a96d301d9fa31d8fcaf
 */
export type IdeaId = string & { readonly _ideaId: never };

/**
 * 提案の識別子
 *  @typePartId 72cc637f6803ef5ca7536889a7fff52e
 */
export type SuggestionId = string & { readonly _suggestionId: never };

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 *  @typePartId b193be207840b5b489517eb5d7b492b2
 */
export type ImageToken = string & { readonly _imageToken: never };

/**
 * パーツの識別子
 *  @typePartId d2c65983f602ee7e0a7be06e6af61acf
 */
export type PartId = string & { readonly _partId: never };

/**
 * 型パーツの識別子
 *  @typePartId 2562ffbc386c801f5132e10b945786e0
 */
export type TypePartId = string & { readonly _typePartId: never };

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 * @typePartId ccf22e92cea3639683c0271d65d00673
 */
export const Int32: { readonly codec: Codec<Int32> } = {
  codec: {
    encode: (value: Int32): ReadonlyArray<number> => {
      let rest: number = value | 0;
      const result: Array<number> = [];
      while (true) {
        const byte: number = rest & 127;
        rest >>= 7;
        if (
          (rest === 0 && (byte & 64) === 0) ||
          (rest === -1 && (byte & 64) !== 0)
        ) {
          result.push(byte);
          return result;
        }
        result.push(byte | 128);
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Int32; readonly nextIndex: number } => {
      let result: number = 0;
      let offset: number = 0;
      while (true) {
        const byte: number = binary[index + offset];
        result |= (byte & 127) << (offset * 7);
        offset += 1;
        if ((128 & byte) === 0) {
          if (offset * 7 < 32 && (byte & 64) !== 0) {
            return {
              result: result | (~0 << (offset * 7)),
              nextIndex: index + offset,
            };
          }
          return { result, nextIndex: index + offset };
        }
      }
    },
  },
};

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 * @typePartId 743d625544767e750c453fa344194599
 */
export const Binary: { readonly codec: Codec<Binary> } = {
  codec: {
    encode: (value: Binary): ReadonlyArray<number> =>
      Int32.codec.encode(value.length).concat([...value]),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Binary; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      return { result: binary.slice(length.nextIndex, nextIndex), nextIndex };
    },
  },
};

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 * @typePartId 93e91ed730b5e7689250a76096ae60a4
 */
export const Bool: {
  /**
   * 真
   */
  readonly True: Bool;
  /**
   * 偽
   */
  readonly False: Bool;
  readonly codec: Codec<Bool>;
} = {
  True: true,
  False: false,
  codec: {
    encode: (value: Bool): ReadonlyArray<number> => [value ? 1 : 0],
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Bool; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Bool.True, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Bool.False, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * リスト. JavaScriptのArrayで扱う
 * @typePartId d7a1efe440138793962eed5625de8196
 */
export const List: {
  readonly codec: <e extends unknown>(a: Codec<e>) => Codec<List<e>>;
} = {
  codec: <e extends unknown>(eCodec: Codec<e>): Codec<List<e>> => ({
    encode: (value: List<e>): ReadonlyArray<number> => {
      let result: Array<number> = Int32.codec.encode(value.length) as Array<
        number
      >;
      for (const element of value) {
        result = result.concat(eCodec.encode(element));
      }
      return result;
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: List<e>; readonly nextIndex: number } => {
      const lengthResult: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      let nextIndex: number = lengthResult.nextIndex;
      const result: Array<e> = [];
      for (let i = 0; i < lengthResult.result; i += 1) {
        const resultAndNextIndex: {
          readonly result: e;
          readonly nextIndex: number;
        } = eCodec.decode(nextIndex, binary);
        result.push(resultAndNextIndex.result);
        nextIndex = resultAndNextIndex.nextIndex;
      }
      return { result, nextIndex };
    },
  }),
};

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつける?
 * @typePartId cdd7dd74dd0f2036b44dcae6aaac46f5
 */
export const Maybe: {
  /**
   * 値があるということ
   */
  readonly Just: <value extends unknown>(a: value) => Maybe<value>;
  /**
   * 値がないということ
   */
  readonly Nothing: <value extends unknown>() => Maybe<value>;
  readonly codec: <value extends unknown>(
    a: Codec<value>
  ) => Codec<Maybe<value>>;
} = {
  Just: <value extends unknown>(value: value): Maybe<value> => ({
    _: "Just",
    value,
  }),
  Nothing: <value extends unknown>(): Maybe<value> => ({ _: "Nothing" }),
  codec: <value extends unknown>(
    valueCodec: Codec<value>
  ): Codec<Maybe<value>> => ({
    encode: (value: Maybe<value>): ReadonlyArray<number> => {
      switch (value._) {
        case "Just": {
          return [0].concat(valueCodec.encode(value.value));
        }
        case "Nothing": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Maybe<value>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: value;
          readonly nextIndex: number;
        } = valueCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Maybe.Just(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return { result: Maybe.Nothing(), nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 * @typePartId 943ef399d0891f897f26bc02fa24af70
 */
export const Result: {
  /**
   * 成功
   */
  readonly Ok: <ok extends unknown, error extends unknown>(
    a: ok
  ) => Result<ok, error>;
  /**
   * 失敗
   */
  readonly Error: <ok extends unknown, error extends unknown>(
    a: error
  ) => Result<ok, error>;
  readonly codec: <ok extends unknown, error extends unknown>(
    a: Codec<ok>,
    b: Codec<error>
  ) => Codec<Result<ok, error>>;
} = {
  Ok: <ok extends unknown, error extends unknown>(
    ok: ok
  ): Result<ok, error> => ({ _: "Ok", ok }),
  Error: <ok extends unknown, error extends unknown>(
    error: error
  ): Result<ok, error> => ({ _: "Error", error }),
  codec: <ok extends unknown, error extends unknown>(
    okCodec: Codec<ok>,
    errorCodec: Codec<error>
  ): Codec<Result<ok, error>> => ({
    encode: (value: Result<ok, error>): ReadonlyArray<number> => {
      switch (value._) {
        case "Ok": {
          return [0].concat(okCodec.encode(value.ok));
        }
        case "Error": {
          return [1].concat(errorCodec.encode(value.error));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Result<ok, error>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: ok;
          readonly nextIndex: number;
        } = okCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Ok(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: error;
          readonly nextIndex: number;
        } = errorCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Error(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 * @typePartId f1f830d23ffab8cec4d0191d157b9fc4
 */
export const String: { readonly codec: Codec<String> } = {
  codec: {
    encode: (value: String): ReadonlyArray<number> => {
      const result: ReadonlyArray<number> = [
        ...new (process === undefined || process.title === "browser"
          ? TextEncoder
          : a.TextEncoder)().encode(value),
      ];
      return Int32.codec.encode(result.length).concat(result);
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: String; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      const textBinary: Uint8Array = binary.slice(length.nextIndex, nextIndex);
      const isBrowser: boolean =
        process === undefined || process.title === "browser";
      if (isBrowser) {
        return { result: new TextDecoder().decode(textBinary), nextIndex };
      }
      return { result: new a.TextDecoder().decode(textBinary), nextIndex };
    },
  },
};

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 * @typePartId fa64c1721a3285f112a4118b66b43712
 */
export const Time: { readonly codec: Codec<Time> } = {
  codec: {
    encode: (value: Time): ReadonlyArray<number> =>
      Int32.codec
        .encode(value.day)
        .concat(Int32.codec.encode(value.millisecond)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Time; readonly nextIndex: number } => {
      const dayAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const millisecondAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(dayAndNextIndex.nextIndex, binary);
      return {
        result: {
          day: dayAndNextIndex.result,
          millisecond: millisecondAndNextIndex.result,
        },
        nextIndex: millisecondAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ログインのURLを発行するために必要なデータ
 * @typePartId db245392b9296a48a195e4bd8824dd2b
 */
export const RequestLogInUrlRequestData: {
  readonly codec: Codec<RequestLogInUrlRequestData>;
} = {
  codec: {
    encode: (value: RequestLogInUrlRequestData): ReadonlyArray<number> =>
      OpenIdConnectProvider.codec
        .encode(value.openIdConnectProvider)
        .concat(UrlData.codec.encode(value.urlData)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: RequestLogInUrlRequestData;
      readonly nextIndex: number;
    } => {
      const openIdConnectProviderAndNextIndex: {
        readonly result: OpenIdConnectProvider;
        readonly nextIndex: number;
      } = OpenIdConnectProvider.codec.decode(index, binary);
      const urlDataAndNextIndex: {
        readonly result: UrlData;
        readonly nextIndex: number;
      } = UrlData.codec.decode(
        openIdConnectProviderAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          openIdConnectProvider: openIdConnectProviderAndNextIndex.result,
          urlData: urlDataAndNextIndex.result,
        },
        nextIndex: urlDataAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 * @typePartId 0264130f1d9473f670907755cbee50d9
 */
export const OpenIdConnectProvider: {
  /**
   * Google ( https://developers.google.com/identity/sign-in/web/ )
   */
  readonly Google: OpenIdConnectProvider;
  /**
   * GitHub ( https://developer.github.com/v3/guides/basics-of-authentication/ )
   */
  readonly GitHub: OpenIdConnectProvider;
  readonly codec: Codec<OpenIdConnectProvider>;
} = {
  Google: "Google",
  GitHub: "GitHub",
  codec: {
    encode: (value: OpenIdConnectProvider): ReadonlyArray<number> => {
      switch (value) {
        case "Google": {
          return [0];
        }
        case "GitHub": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: OpenIdConnectProvider;
      readonly nextIndex: number;
    } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: OpenIdConnectProvider.Google,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: OpenIdConnectProvider.GitHub,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * デバッグモードかどうか,言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある. デバッグ時のホスト名は http://localhost になる
 * @typePartId dc3b3cd3f125b344fb60a91c0b184f3e
 */
export const UrlData: { readonly codec: Codec<UrlData> } = {
  codec: {
    encode: (value: UrlData): ReadonlyArray<number> =>
      ClientMode.codec
        .encode(value.clientMode)
        .concat(Location.codec.encode(value.location))
        .concat(Language.codec.encode(value.language)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UrlData; readonly nextIndex: number } => {
      const clientModeAndNextIndex: {
        readonly result: ClientMode;
        readonly nextIndex: number;
      } = ClientMode.codec.decode(index, binary);
      const locationAndNextIndex: {
        readonly result: Location;
        readonly nextIndex: number;
      } = Location.codec.decode(clientModeAndNextIndex.nextIndex, binary);
      const languageAndNextIndex: {
        readonly result: Language;
        readonly nextIndex: number;
      } = Language.codec.decode(locationAndNextIndex.nextIndex, binary);
      return {
        result: {
          clientMode: clientModeAndNextIndex.result,
          location: locationAndNextIndex.result,
          language: languageAndNextIndex.result,
        },
        nextIndex: languageAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * デバッグモードか, リリースモード
 * @typePartId 261b20a84f5b94b93559aaf98ffc6d33
 */
export const ClientMode: {
  /**
   * デバッグモード. オリジンは http://localshot:2520
   */
  readonly DebugMode: ClientMode;
  /**
   * リリースモード. オリジンは https://definy.app
   */
  readonly Release: ClientMode;
  readonly codec: Codec<ClientMode>;
} = {
  DebugMode: "DebugMode",
  Release: "Release",
  codec: {
    encode: (value: ClientMode): ReadonlyArray<number> => {
      switch (value) {
        case "DebugMode": {
          return [0];
        }
        case "Release": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ClientMode; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: ClientMode.DebugMode,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: ClientMode.Release,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 * @typePartId e830168583e34ff0750716aa6b253c5f
 */
export const Location: {
  /**
   * 最初のページ
   */
  readonly Home: Location;
  /**
   * プロジェクト作成画面
   */
  readonly CreateProject: Location;
  /**
   * プロジェクトの詳細ページ
   */
  readonly Project: (a: ProjectId) => Location;
  /**
   * ユーザーの詳細ページ
   */
  readonly User: (a: UserId) => Location;
  /**
   * アイデア詳細ページ
   */
  readonly Idea: (a: IdeaId) => Location;
  /**
   * 提案のページ
   */
  readonly Suggestion: (a: SuggestionId) => Location;
  /**
   * Definyについて説明したページ
   */
  readonly About: Location;
  /**
   * デバッグページ
   */
  readonly Debug: Location;
  readonly codec: Codec<Location>;
} = {
  Home: { _: "Home" },
  CreateProject: { _: "CreateProject" },
  Project: (projectId: ProjectId): Location => ({ _: "Project", projectId }),
  User: (userId: UserId): Location => ({ _: "User", userId }),
  Idea: (ideaId: IdeaId): Location => ({ _: "Idea", ideaId }),
  Suggestion: (suggestionId: SuggestionId): Location => ({
    _: "Suggestion",
    suggestionId,
  }),
  About: { _: "About" },
  Debug: { _: "Debug" },
  codec: {
    encode: (value: Location): ReadonlyArray<number> => {
      switch (value._) {
        case "Home": {
          return [0];
        }
        case "CreateProject": {
          return [1];
        }
        case "Project": {
          return [2].concat(ProjectId.codec.encode(value.projectId));
        }
        case "User": {
          return [3].concat(UserId.codec.encode(value.userId));
        }
        case "Idea": {
          return [4].concat(IdeaId.codec.encode(value.ideaId));
        }
        case "Suggestion": {
          return [5].concat(SuggestionId.codec.encode(value.suggestionId));
        }
        case "About": {
          return [6];
        }
        case "Debug": {
          return [7];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Location; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Location.Home, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return {
          result: Location.CreateProject,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: ProjectId;
          readonly nextIndex: number;
        } = ProjectId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Project(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: UserId;
          readonly nextIndex: number;
        } = UserId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.User(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        const result: {
          readonly result: IdeaId;
          readonly nextIndex: number;
        } = IdeaId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Idea(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        const result: {
          readonly result: SuggestionId;
          readonly nextIndex: number;
        } = SuggestionId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Suggestion(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        return { result: Location.About, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 7) {
        return { result: Location.Debug, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 英語,日本語,エスペラント語などの言語
 * @typePartId a7c52f1164c69f56625e8febd5f44bf3
 */
export const Language: {
  /**
   * 日本語
   */
  readonly Japanese: Language;
  /**
   * 英語
   */
  readonly English: Language;
  /**
   * エスペラント語
   */
  readonly Esperanto: Language;
  readonly codec: Codec<Language>;
} = {
  Japanese: "Japanese",
  English: "English",
  Esperanto: "Esperanto",
  codec: {
    encode: (value: Language): ReadonlyArray<number> => {
      switch (value) {
        case "Japanese": {
          return [0];
        }
        case "English": {
          return [1];
        }
        case "Esperanto": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Language; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Language.Japanese, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Language.English, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 2) {
        return {
          result: Language.Esperanto,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * ユーザーのデータのスナップショット
 * @typePartId 655cea387d1aca74e54df4fc2888bcbb
 */
export const User: { readonly codec: Codec<User> } = {
  codec: {
    encode: (value: User): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(ImageToken.codec.encode(value.imageHash))
        .concat(String.codec.encode(value.introduction))
        .concat(Time.codec.encode(value.createTime))
        .concat(List.codec(ProjectId.codec).encode(value.likeProjectIdList))
        .concat(List.codec(ProjectId.codec).encode(value.developProjectIdList))
        .concat(List.codec(IdeaId.codec).encode(value.commentIdeaIdList))
        .concat(Time.codec.encode(value.getTime)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: User; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const imageHashAndNextIndex: {
        readonly result: ImageToken;
        readonly nextIndex: number;
      } = ImageToken.codec.decode(nameAndNextIndex.nextIndex, binary);
      const introductionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(imageHashAndNextIndex.nextIndex, binary);
      const createTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(introductionAndNextIndex.nextIndex, binary);
      const likeProjectIdListAndNextIndex: {
        readonly result: List<ProjectId>;
        readonly nextIndex: number;
      } = List.codec(ProjectId.codec).decode(
        createTimeAndNextIndex.nextIndex,
        binary
      );
      const developProjectIdListAndNextIndex: {
        readonly result: List<ProjectId>;
        readonly nextIndex: number;
      } = List.codec(ProjectId.codec).decode(
        likeProjectIdListAndNextIndex.nextIndex,
        binary
      );
      const commentIdeaIdListAndNextIndex: {
        readonly result: List<IdeaId>;
        readonly nextIndex: number;
      } = List.codec(IdeaId.codec).decode(
        developProjectIdListAndNextIndex.nextIndex,
        binary
      );
      const getTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(commentIdeaIdListAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          imageHash: imageHashAndNextIndex.result,
          introduction: introductionAndNextIndex.result,
          createTime: createTimeAndNextIndex.result,
          likeProjectIdList: likeProjectIdListAndNextIndex.result,
          developProjectIdList: developProjectIdListAndNextIndex.result,
          commentIdeaIdList: commentIdeaIdListAndNextIndex.result,
          getTime: getTimeAndNextIndex.result,
        },
        nextIndex: getTimeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * データを識別するIdとデータ
 * @typePartId 12a442ac046b1757e8684652c2669450
 */
export const IdAndData: {
  readonly codec: <id extends unknown, data extends unknown>(
    a: Codec<id>,
    b: Codec<data>
  ) => Codec<IdAndData<id, data>>;
} = {
  codec: <id extends unknown, data extends unknown>(
    idCodec: Codec<id>,
    dataCodec: Codec<data>
  ): Codec<IdAndData<id, data>> => ({
    encode: (value: IdAndData<id, data>): ReadonlyArray<number> =>
      idCodec.encode(value.id).concat(dataCodec.encode(value.data)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IdAndData<id, data>; readonly nextIndex: number } => {
      const idAndNextIndex: {
        readonly result: id;
        readonly nextIndex: number;
      } = idCodec.decode(index, binary);
      const dataAndNextIndex: {
        readonly result: data;
        readonly nextIndex: number;
      } = dataCodec.decode(idAndNextIndex.nextIndex, binary);
      return {
        result: { id: idAndNextIndex.result, data: dataAndNextIndex.result },
        nextIndex: dataAndNextIndex.nextIndex,
      };
    },
  }),
};

/**
 * プロジェクト
 * @typePartId 3fb93c7e94724891d2a224c6f945acbd
 */
export const Project: { readonly codec: Codec<Project> } = {
  codec: {
    encode: (value: Project): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(ImageToken.codec.encode(value.iconHash))
        .concat(ImageToken.codec.encode(value.imageHash))
        .concat(Time.codec.encode(value.createTime))
        .concat(UserId.codec.encode(value.createUserId))
        .concat(Time.codec.encode(value.updateTime))
        .concat(Time.codec.encode(value.getTime))
        .concat(List.codec(PartId.codec).encode(value.partIdList))
        .concat(List.codec(TypePartId.codec).encode(value.typePartIdList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Project; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const iconHashAndNextIndex: {
        readonly result: ImageToken;
        readonly nextIndex: number;
      } = ImageToken.codec.decode(nameAndNextIndex.nextIndex, binary);
      const imageHashAndNextIndex: {
        readonly result: ImageToken;
        readonly nextIndex: number;
      } = ImageToken.codec.decode(iconHashAndNextIndex.nextIndex, binary);
      const createTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(imageHashAndNextIndex.nextIndex, binary);
      const createUserIdAndNextIndex: {
        readonly result: UserId;
        readonly nextIndex: number;
      } = UserId.codec.decode(createTimeAndNextIndex.nextIndex, binary);
      const updateTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(createUserIdAndNextIndex.nextIndex, binary);
      const getTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(updateTimeAndNextIndex.nextIndex, binary);
      const partIdListAndNextIndex: {
        readonly result: List<PartId>;
        readonly nextIndex: number;
      } = List.codec(PartId.codec).decode(
        getTimeAndNextIndex.nextIndex,
        binary
      );
      const typePartIdListAndNextIndex: {
        readonly result: List<TypePartId>;
        readonly nextIndex: number;
      } = List.codec(TypePartId.codec).decode(
        partIdListAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          iconHash: iconHashAndNextIndex.result,
          imageHash: imageHashAndNextIndex.result,
          createTime: createTimeAndNextIndex.result,
          createUserId: createUserIdAndNextIndex.result,
          updateTime: updateTimeAndNextIndex.result,
          getTime: getTimeAndNextIndex.result,
          partIdList: partIdListAndNextIndex.result,
          typePartIdList: typePartIdListAndNextIndex.result,
        },
        nextIndex: typePartIdListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * プロジェクトの識別子
 * @typePartId 4e3ab0f9499404a5fa100c4b57835906
 */
export const ProjectId: { readonly codec: Codec<ProjectId> } = {
  codec: {
    encode: (value: ProjectId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ProjectId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: ProjectId;
        readonly nextIndex: number;
      },
  },
};

/**
 * ユーザーの識別子
 * @typePartId 5a71cddc0b95298cb57ec66089190e9b
 */
export const UserId: { readonly codec: Codec<UserId> } = {
  codec: {
    encode: (value: UserId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UserId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: UserId;
        readonly nextIndex: number;
      },
  },
};

/**
 * アイデアの識別子
 * @typePartId 719fa4020ae23a96d301d9fa31d8fcaf
 */
export const IdeaId: { readonly codec: Codec<IdeaId> } = {
  codec: {
    encode: (value: IdeaId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IdeaId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: IdeaId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 提案の識別子
 * @typePartId 72cc637f6803ef5ca7536889a7fff52e
 */
export const SuggestionId: { readonly codec: Codec<SuggestionId> } = {
  codec: {
    encode: (value: SuggestionId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: SuggestionId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: SuggestionId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 * @typePartId b193be207840b5b489517eb5d7b492b2
 */
export const ImageToken: { readonly codec: Codec<ImageToken> } = {
  codec: {
    encode: (value: ImageToken): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImageToken; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: ImageToken;
        readonly nextIndex: number;
      },
  },
};

/**
 * パーツの識別子
 * @typePartId d2c65983f602ee7e0a7be06e6af61acf
 */
export const PartId: { readonly codec: Codec<PartId> } = {
  codec: {
    encode: (value: PartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: PartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: PartId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 型パーツの識別子
 * @typePartId 2562ffbc386c801f5132e10b945786e0
 */
export const TypePartId: { readonly codec: Codec<TypePartId> } = {
  codec: {
    encode: (value: TypePartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: TypePartId;
        readonly nextIndex: number;
      },
  },
};
